import requests
import random
import time
import os
import urllib3
import threading
import sys
import shutil
import requests
import pyautogui
import pyperclip
import time
import subprocess
from pymsgbox import password


os.system("chcp 65001")
os.system("cls")
os.system("title Nigga Puller - by so9a")

def get_terminal_width():
    """Get the width of the terminal window."""
    return shutil.get_terminal_size((80, 20)).columns

def center_text(text, width):
    """Center the text based on the terminal width."""
    return text.center(width)

def rgb_to_ansi(r, g, b):
    """Convert RGB values to ANSI escape code."""
    return f"\033[38;2;{r};{g};{b}m"
#level
def smooth_gradient_print(text, start_color, end_color):
    """Print text with a smooth gradient between start_color and end_color."""
    length = len(text)
    r1, g1, b1 = start_color
    r2, g2, b2 = end_color

    for i, char in enumerate(text):
        if char != " ":
            ratio = i / max(length - 1, 1)
            r = int(r1 + (r2 - r1) * ratio)
            g = int(g1 + (g2 - g1) * ratio)
            b = int(b1 + (b2 - b1) * ratio)
            sys.stdout.write(f"{rgb_to_ansi(r, g, b)}{char}")
        else:
            sys.stdout.write(char)
    sys.stdout.write("\033[0m\n")  # Reset color after line

# Override the default print function
def print_gradient(text, start_color=(255, 0, 0), end_color=(75, 0, 148)):
    smooth_gradient_print(text, start_color, end_color)

start_color = (255, 0, 0)    # Red
end_color = (75, 0, 148)

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
DomainExpansion = threading.Event()

# Generate random account IDs based on the year
def generate_account_id(year):
    if year == 2016:
        return random.randint(1, 69723)
    elif year == 2017:
        return random.randint(69724, 400000)
    elif year == 2018:
        return random.randint(400001, 1290001)
    elif year == 2019:
        return random.randint(1290002, 3314552)
    elif year == 2020:
        return random.randint(3314553, 11159631)
    elif year == 2021:
        return random.randint(11159632, 40734808)
    elif year == 1:
        return random.randint(3464457, 6464457)
    #elif year == 3:
    #    with open(Teachers, 'r') as file:
    #     year = [line.strip() for line in file if line.strip().isdigit()]
    else:
        raise ValueError("Invalid year")

# Fetch account data from the API
def fetch_account_data(account_id):
    account_url = f"https://apim.rec.net/accounts/account/{account_id}"
    try:
        response = requests.get(account_url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as e:
        if response.status_code == 404:
            return None
        elif response.status_code == 429:
            DomainExpansion.set()
            time.sleep(5)
            DomainExpansion.clear()
            return None
        elif response.status_code == 403:
            print_gradient(f"ERROR: Access forbidden")
            os.system("exit")
        else:
            print_gradient(f"ERROR: HTTP error occurred")
            os.system("exit")
    except requests.exceptions.RequestException as e:
        print_gradient(f"ERROR: Request exception occurred")
        os.system("exit")

# Check if the username is in the leak database
def check_leak_database(username):
    url = f"https://leakcheck.io/api/public?check={username}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return data.get("success", False)
    return False

# Cleo Puller title
CLEO_TITLE = f"""
 /$$   /$$ /$$$$$$  /$$$$$$   /$$$$$$   /$$$$$$          /$$$$$$$  /$$   /$$ /$$       /$$       /$$$$$$$$ /$$$$$$$ 
| $$$ | $$|_  $$_/ /$$__  $$ /$$__  $$ /$$__  $$        | $$__  $$| $$  | $$| $$      | $$      | $$_____/| $$__  $$
| $$$$| $$  | $$  | $$  \__/| $$  \__/| $$  \ $$        | $$  \ $$| $$  | $$| $$      | $$      | $$      | $$  \ $$
| $$ $$ $$  | $$  | $$ /$$$$| $$ /$$$$| $$$$$$$$ /$$$$$$| $$$$$$$/| $$  | $$| $$      | $$      | $$$$$   | $$$$$$$/
| $$  $$$$  | $$  | $$|_  $$| $$|_  $$| $$__  $$|______/| $$____/ | $$  | $$| $$      | $$      | $$__/   | $$__  $$
| $$\  $$$  | $$  | $$  \ $$| $$  \ $$| $$  | $$        | $$      | $$  | $$| $$      | $$      | $$      | $$  \ $$
| $$ \  $$ /$$$$$$|  $$$$$$/|  $$$$$$/| $$  | $$        | $$      |  $$$$$$/| $$$$$$$$| $$$$$$$$| $$$$$$$$| $$  | $$
|__/  \__/|______/ \______/  \______/ |__/  |__/        |__/       \______/ |________/|________/|________/|__/  |__/

"""

def cleo_puller():
    print_gradient(CLEO_TITLE)
    with open("Token.txt", "r") as f:
        discord_token = f.read()

    channel_id = int(input(f"                                       \x1b[38;5;127mEnter Discord Channel ID: "))
    delay = int(input(f"                                        \x1b[38;5;127mEnter delay: "))
    year = int(input(f"                                     \x1b[38;5;127mEnter the year you like to generate IDs for (2016 - 2021) for 'fnaf' type 1: "))
    level_number = input(f"                                   \x1b[38;5;127mEnter Level you want (Enter Nothing for no level): ")

    os.system("cls")
    headers = {
        "Authorization": discord_token,
        'Accept': '*/*',
        'Accept-Language': 'es-ES,es;q=0.9',
        'Connection': 'keep-alive',
        'Referer': 'https://discord.com/',
        'Sec-Fetch-Dest': 'empty',
        'Sec-Fetch-Mode': 'cors',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-GPC': '1',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        'X-Track': 'eyJvcyI6IklPUyIsImJyb3dzZXIiOiJTYWZlIiwic3lzdGVtX2xvY2FsZSI6ImVuLUdCIiwiYnJvd3Nlcl91c2VyX2FnZW50IjoiTW96aWxsYS81LjAgKElQaG9uZTsgQ1BVIEludGVybmFsIFByb2R1Y3RzIFN0b3JlLCBhcHBsaWNhdGlvbi8yMDUuMS4xNSAoS0hUTUwpIFZlcnNpb24vMTUuMCBNb2JpbGUvMTVFMjQ4IFNhZmFyaS82MDQuMSIsImJyb3dzZXJfdmVyc2lvbiI6IjE1LjAiLCJvc192IjoiIiwicmVmZXJyZXIiOiIiLCJyZWZlcnJpbmdfZG9tYWluIjoiIiwicmVmZXJyZXJfZG9tYWluX2Nvb2tpZSI6InN0YWJsZSIsImNsaWVudF9idWlsZF9udW1iZXIiOjk5OTksImNsaWVudF9ldmVudF9zb3VyY2UiOiJzdGFibGUiLCJjbGllbnRfZXZlbnRfc291cmNlIjoic3RhYmxlIn0'
    }

    user = requests.get("https://discord.com/api/v9/users/@me", headers=headers)
    if user.status_code != 200:
        print_gradient(f"ERROR: Invalid Discord token.")
        time.sleep(3)
        os.system("exit")

    no_delay = True
    while True:
        if not no_delay:
            time.sleep(delay)
        else:
            no_delay = False
#429
        account_id = generate_account_id(year)
        account_data = fetch_account_data(account_id)

        if account_data is None:
            print_gradient(f"ERROR: Unable to fetch account data")
            no_delay = True
            continue

        username = account_data.get('username', 'Unknown Username')

        if 'Guest-' in username or 'User-' in username:
            print_gradient(f"Skipping guest accounts.")
            no_delay = True
            continue

        if not check_leak_database(username):
            print_gradient(f"Skipping '{username}'")
            no_delay = True
            continue

        # Fixed URL by adding 'https://'
        level_api_url = f"https://api.rec.net/api/players/v2/progression/bulk?id={account_id}"
        level_response = requests.get(level_api_url)
        if level_response.status_code == 200:
            level_data = level_response.json()
            if isinstance(level_data, list) and level_data:
                level_found = False#==
                for user_data in level_data:
                    level = user_data.get('Level')
                    if level == level_number:
                        print_gradient(f"Level Found for account: {username}")
                        level_found = True
                        break
                    if level_number == "":
                        print_gradient(f"Level Found for account: {username}")
                        level_found = True
                        break
                # Skip to the next account if the level is not found
                if not level_found:
                    print_gradient(f"Level not same level u put for account: {username}. acc level is {level}")
                    no_delay = True
                    continue
            else:
                print_gradient(f"ERROR: Invalid level data format.")
                no_delay = True
                continue
        else:
            print_gradient(f"ERROR: Failed to fetch level data for account: {username}")
            no_delay = True
            continue

        # If the level is found, send the message to Discord
        message_content = f"-check {username}"
        discord_url = f"https://discord.com/api/v9/channels/{channel_id}/messages"
        payload = {"content": message_content}
        senddiscord = requests.post(discord_url, payload, headers=headers)
        if senddiscord == "<Response [200]>":
            print_gradient(f"{username} has been sended")
            continue
        if senddiscord == "<Response [403]>":
            print_gradient("add new token plz daddy!")
            time.sleep(5)
            return#level found

cleo_puller()
